# Copyright edalize contributors
# Licensed under the 2-Clause BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-2-Clause
import logging
import os

from edalize.edatool import Edatool

logger = logging.getLogger(__name__)

MAKE_HEADER = """#Generated by Edalize
ifeq (, $(shell which xmroot))
$(error "No Xcelium installation in $(PATH)")
endif

XCELIUM_HOME = $(shell xmroot)

XRUN ?= $(XCELIUM_HOME)/tools/bin/xrun

TOPLEVEL      := {toplevel}
XRUN_OPTIONS  ?= {xrun_options}
RULEFILES     ?= {rulefiles}
DESIGN_INFO   ?= {design_info}
EXTRA_OPTIONS ?= $(XRUN_OPTIONS) $(RULEFILES) $(DESIGN_INFO)

XRUN_CALL = $(XRUN) -hal -sv -q -f edalize_main.f $(EXTRA_OPTIONS) -top $(TOPLEVEL)

all:

run:
\t$(XRUN_CALL)

clean:
"""


class Hal(Edatool):

    argtypes = ["vlogdefine"]

    @classmethod
    def get_doc(cls, api_ver):
        if api_ver == 0:
            return {
                "description": (
                    "Xcelium HAL (Hardware Abstraction Linting) from Cadence Design"
                    " Systems"
                ),
                "lists": [
                    {
                        "name": "xrun_options",
                        "type": "String",
                        "desc": "Additional run options for xrun",
                    },
                ],
            }

    def _write_filelist(self):
        """Write a clean .f file with defines, libext, incdirs, and source files.

        Also collects halDef and designInfo files for use in the Makefile.
        """
        f_file = open(os.path.join(self.work_root, "edalize_main.f"), "w")

        (src_files, incdirs) = self._get_fileset_files()

        # Collect HAL-specific files (with uniqueness check)
        self.rulefiles = []
        self.design_info_files = []
        seen_rulefiles = set()
        seen_design_info = set()

        # Write defines (one per line)
        for k, v in self.vlogdefine.items():
            f_file.write(f"+define+{k}={self._param_value_str(v)}\n")

        # Write include directories (one per line)
        for d in incdirs:
            f_file.write("+incdir+{}\n".format(d.replace("\\", "/")))

        # Process source files
        for f in src_files:
            if f.file_type.startswith("verilogSource") or f.file_type.startswith(
                "systemVerilogSource",
            ):
                f_file.write("{}\n".format(f.name.replace("\\", "/")))
            elif f.file_type.startswith("vhdlSource"):
                logger.warning(
                    f"HAL does not support VHDL files, skipping: {f.name}",
                )
            elif f.file_type == "halDef":
                filepath = f.name.replace("\\", "/")
                if filepath not in seen_rulefiles:
                    self.rulefiles.append(filepath)
                    seen_rulefiles.add(filepath)
                else:
                    logger.warning(f"Duplicate halDef file ignored: {filepath}")
            elif f.file_type == "designInfo":
                filepath = f.name.replace("\\", "/")
                if filepath not in seen_design_info:
                    self.design_info_files.append(filepath)
                    seen_design_info.add(filepath)
                else:
                    logger.warning(
                        f"Duplicate designInfo file ignored: {filepath}",
                    )
            elif f.file_type == "user":
                pass
            else:
                _s = "{} has unknown file type '{}'"
                logger.warning(_s.format(f.name, f.file_type))

        f_file.close()

    def _write_makefile(self):
        makefile = open(os.path.join(self.work_root, "Makefile"), "w")

        _xrun_options = self.tool_options.get("xrun_options", [])

        # Build -rulefile options
        _rulefiles = " ".join([f"-rulefile {f}" for f in self.rulefiles])

        # Build -design_info options
        _design_info = " ".join(
            [f"-design_info {f}" for f in self.design_info_files],
        )

        _s = MAKE_HEADER.format(
            toplevel=self.toplevel,
            xrun_options=" ".join(_xrun_options),
            rulefiles=_rulefiles,
            design_info=_design_info,
        )
        makefile.write(_s)
        makefile.close()

    def configure_main(self):
        self._write_filelist()
        self._write_makefile()

    def run_main(self):
        args = ["run"]
        self._run_tool("make", args)
